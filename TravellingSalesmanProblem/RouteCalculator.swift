//
//  routeCalculator.swift
//  TravellingSalesmanProblem
//
//  Created by Teodor Afrim on 22.04.18.
//  Copyright Â© 2018 Teodor Afrim. All rights reserved.
//

import Foundation
import MapKit

/**
 A delegate-protocol used to pass errors to a view controller.
 */
protocol ErrorDelegate: class {
    func passError(_ error: Error)
}

class RouteCalculator {
    
    weak var errorDelegate: ErrorDelegate?
    
    /**
     
     An array where all the places that need to be visited are stored.
     
     - note: Position 0 represents the starting point.
     */
    var placesToVisit: [MKMapItem]
    
    /**
     
     The matrix where all the routes from each place to every other one are stored.
     */
    lazy var routesMatrix: [[MKRoute]] = {
        // Initialize as a n*n matrix, where n is the number of elements from the array with map items.
        var toReturn = [[MKRoute]]()
        var n = placesToVisit.count
        var row = [MKRoute]()
        for _ in 0...n {
            row.append(MKRoute())
        }
        for _ in 0...n {
            toReturn.append(row)
        }
        return toReturn
    }()
    
    
    var numberOfCalculatedRoutes = 0
    /**
     
     The DispatchGroup that tracks if the routesMatrix is ready to use.
     */
    let routesMatrixDispatchGroup = DispatchGroup()
    
    init (with placesToVisit: [MKMapItem]) {
        self.placesToVisit = placesToVisit
    }
    
    /**
     
     Calculate all the routes from each place to every other one and save them in
     the routesMatrix.
     
     - warning: Each route calculation process is asynchronous. Must be used only within
     routesMatrixDispatchGroup.notify(), otherwise the matrix might be either empty or not completed.
     */
    func fillTheRoutesMatrix() {
        for rowIndex in 0...(placesToVisit.count-1) {
            for columnIndex in 0...(placesToVisit.count-1) {
                // We don't need to calculate the distance from a place to itself.
                if rowIndex != columnIndex {
                    calculateAndAddRouteToMatrix(from: placesToVisit[rowIndex], to: placesToVisit[columnIndex], at: (row: rowIndex, column: columnIndex))
                }
            }
        }
    }
    
    /**
     
     Return, through a completion handler, the routes and the names of the places, in the optimal order. Will be passed to the ViewController as the final result.
 */
    
    func calculateBestPath(completionHandler: @escaping ([MKRoute], [String]) -> Void) {
        routesMatrixDispatchGroup.enter() //start monitoring
        fillTheRoutesMatrix() //start calculating the distances
        // Wait until the matrix is completed
        routesMatrixDispatchGroup.notify(queue: .main, execute: {
            
            // From this moment we know that distancesMatrix is ready to use, so we start
            // the genetic algorithm.
            
            var waypoints = [GAWaypoint]()
            for index in 0..<self.placesToVisit.count {
                let waypoint = GAWaypoint(position: index)
                waypoints.append(waypoint)
            }
            
            // Create a matrix only with the distances.
            var distancesMatrix = [[Double]](repeating:[Double](repeating:0, count: self.placesToVisit.count), count: self.placesToVisit.count)

            for rowIndex in 0...(self.placesToVisit.count-1) {
                for columnIndex in 0...(self.placesToVisit.count-1) {
                    // We don't need to calculate the distance from a place to itself.
                    if rowIndex != columnIndex {
                        distancesMatrix[rowIndex][columnIndex] = self.routesMatrix[rowIndex][columnIndex].distance
                    }
                    else {
                        distancesMatrix[rowIndex][columnIndex] = 0
                    }
                }
            }
                let geneticAlgorithm = GeneticAlgorithm(for: waypoints, with: distancesMatrix)
                geneticAlgorithm.onNewGeneration = {
                    (path, generation) in
                    DispatchQueue.main.async {
                        // When the algorithm has finished, process the result and send it to the VC
                        if generation == GeneticAlgorithm.numberOfGenerationsLimit {
                            let (bestRoute, orderedBestRouteNames) = self.getOptimalRoute(of: self.placesToVisit, accordingTo: path)
                            completionHandler(bestRoute, orderedBestRouteNames)
                        }
                    }
                }
                geneticAlgorithm.startEvolution()
            
        })
    }
    
    /**
     Take the map items and the path generated by the genetic algorithm and return an array with routes and an array with the names of the places, both sorted in the needed order.
     
     */
    func getOptimalRoute(of mapItems: [MKMapItem], accordingTo path: GAPath) -> ([MKRoute], [String]) {
        
        // Create a new path, keeping the same order, but having the waypoint with the position 0 (which represents the starting point) as the first and also the last item in the path in a shift-like way.
        
        let newPath = GAPath(waypoints: [GAWaypoint(position: 0)])
        newPath.waypoints.removeAll()
         var startingPointIndex = 0
        
        // Find the waypoint with the position 0.
        for index in 0..<path.waypoints.count {
            if path.waypoints[index].position == 0 {
                startingPointIndex = index
            }
        }
        
        // Add it and all his right elements at the beginning of the new path.
        for index in startingPointIndex..<path.waypoints.count {
            newPath.waypoints.append(path.waypoints[index])
        }
        // Append the rest of the elements.
        for index in 0..<startingPointIndex {
            newPath.waypoints.append(path.waypoints[index])
        }
        
        // Add the starting point element one more time, at the end, to have a cycle.
        newPath.waypoints.append(path.waypoints[startingPointIndex])
        
        // Create a new array with routes, in an optimal "traveling salesman" order.
        var routes = [MKRoute]()
        var names = [String]()
        
        for index in 0..<newPath.waypoints.count-1 {
            let source = newPath.waypoints[index].position
            let sourceName = mapItems[source].name
            let destination = newPath.waypoints[index+1].position
            routes.append(routesMatrix[source][destination])
            names.append(sourceName!)
        }
        names.append(mapItems[(newPath.waypoints.last?.position)!].name!)

        return (routes, names)
    }
    
    /**
     
     Calculate the route between two map items and add it to the routesMatrix.
     
     The routesMatrixDispatchGroup will be notified after the last required distance is
     calculated.
     */
    func calculateAndAddRouteToMatrix(from source: MKMapItem, to destination: MKMapItem, at position: (row: Int, column: Int)) {
        let directionRequest = MKDirections.Request()
        directionRequest.source = source
        directionRequest.destination = destination
        directionRequest.transportType = .automobile
        directionRequest.requestsAlternateRoutes = true
        let directions = MKDirections(request: directionRequest)
        directions.calculate(completionHandler: {
            (response, error) in
            
            guard let response = response else {
                if let error = error {
                    print(source, destination)
                    self.errorDelegate?.passError(error) //pass the error to the view controller
                    print("Error: \(error)")
                }
                return
            }
            let route = response.routes[0]
            self.routesMatrix[position.row][position.column] = route
            self.numberOfCalculatedRoutes += 1
            // Notify the DispatchGroup that the last route was calculated
            // and the routesMatrix is ready to use
            let requiredNumberOfDistances = self.placesToVisit.count * self.placesToVisit.count - self.placesToVisit.count
            if self.numberOfCalculatedRoutes == requiredNumberOfDistances {
                self.routesMatrixDispatchGroup.leave()
            }
        })
    }
}

